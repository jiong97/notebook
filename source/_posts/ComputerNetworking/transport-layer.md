---
title: 传输层
date: 2020-11-16 20:24:25
categories: [ComputerNetworking]
excerpt: '运输层协议为两个不同主机上的应用进程之间提供逻辑通讯。应用进程无需关心分组是怎样在网络传输的。运输层将从应用程序接收到的报文转化为运输层分组，该分组被称为运输层报文段（segment）'
---

运输层协议为两个不同主机上的应用进程之间提供逻辑通讯。应用进程无需关心分组是怎样在网络传输的。运输层将从应用程序接收到的报文转化为运输层分组，该分组被称为运输层报文段（segment）。运输层将报文段发给网络层。IP协议是一种不可靠的服务。

运输层最低限度必须提供一种复用与分解服务。

将网络层提供的主机到主机间的交付服务扩展到进程间的交付是一种多路复用技术。socket的唯一标识被称为端口号，一个16bits的数字。

UDP套接字是由目的IP和目的端口组成的二元组，TCP是由源IP、源端口、目的IP、目的端口组成的四元组。

# UDP

UDP几乎没有对IP增加别的东西。UDP使用前，实体之间没有进行握手，所以UDP被称为是无连接的。

## UDP报文格式

![UDP报文格式](/images/computer-networking/transport-layer/udp-segment-structure.png)

UDP首部只有4个字段，每个字段有两个字节组成。长度字段说明了UDP报文的字节数（首部+数据）。校验和计算时，除了UDP报文段以外，还包含IP首部的一些字段。

发送方将所有16比特进行相加取反放在校验和位置，接收方将所有16比特比特与校验和相加，若没有出错则为全1。遇到差错后，某些实现会直接丢弃报文，有的会给出警告。

# TCP

## TCP连接

TCP被称为面向连接，所以两个进程间需先发送一些预备报文。TCP是点对点的、全双工（full duplex）的可靠传输协议。连接状态只保存在端系统中。缓冲区在连接中设置的，TCP允许从缓冲区取出并放入报文段中的数据受限于最大报文段长度（maximum segment size，mss）。mss通常由最大链路层帧长度（最大传输单元mtu）。mss要保证一个TCP报文段加上TCP/IP首部长度。

### TCP报文格式

![TCP报文格式](/images/computer-networking/transport-layer/TCP-segment-structure.png)

- 32bits的序号字段、确认号字段。用来实现发送方和接收方的可靠数据传输服务
- 16bits的接收窗口字段。用于流量控制与指示接收方愿意接受的字节数量
- 4bits的首部长度字段，指示了以32bits为单位的首部长度。由于选项字段的原因，首部长度是可变的
- 选项字段可包含协商的MSS
- Window Size接收方将缓存可用空间告诉发送方，通过将未确认数据大小限制在该值内，达到流量控制的目的
- 6bits的标志字段。ACK用于指示确认字段的值是有效的，对一个已成功接受的报文的确认。PST、SYN、FIN用于连接的建立与拆除。PSH字段用于指示接收方立即数据交给上层。URG指示紧急数据，数据又最后的紧急数据指针字段指出
- RST标识该报文为特殊重置报文（REST）。当主机接收到一个报文，其端口或源IP地址，与该主机Socket都不匹配时发送。UDP端口不匹配时，返回的是ICMP报文。一些端口扫描工具使用了该技术。
- SYN，Synchronize sequence numbers同步序列编号，连接建立中，双方发送的第一个报文
- FIN，断开连接时双方第一次发送的报文


### 滑动窗口协议

![发送方的滑动窗口](/images/computer-networking/transport-layer/window.png)

滑动窗口协议允许接收方同时发送多个分组，滑动窗口将发送的数据分为三个部分。回退N步（GBN）和选择重传（SR）为滑动窗口协议的两种实现。

GBN(Go Back N)，采用累计确认，如收到确认号N，就相当于N之前的分组都已经接收到。如果定时时间超时，则重传序号大于等于sendbase的所有分组。若收到一个大于sendbase的确认号n，则说明n之前的分组都已经接收，将sendbase加到n+1，如果sendbase等于nextseqnum（下一个新建报文的编号），停止定时器，否则启动定时器。

SR(Selective Repeat)协议采用选择重传，该协议同时为通讯双方维护窗口，**接收方**为每个分组单独进行确认，并且设置缓存，等待接收到有序分组后再向上层交付。发送方为每个分组单独设置定时器，超时时只发送未确认的分组。

TCP采用累积确认。

### 建立连接

- 第一步。客户端的TCP首先会向服务端发送一个特殊的TCP报文段，它不包含应用层数据。该报文段首部的SYN位被置为1，因此被称为SYN报文。客户端会随机选择一个初始序列号client_isn，并放置在SYN报文的序号字段中
- 第二步。服务器从为该连接分配变量和缓存，并向客户端发送允许TCP连接的报文段。该报文也不包含应用层数据，首部中SYN字段被置为1，确认号字段被置为client_isn+1，序号字段被置为服务器自己的初始序列号。该报文被称为SYNACK报文
- 第三步。收到SYNACK报文段后，客户端也要为连接分配变量和缓存。客户端再向服务器发送另一个报文段，对服务器允许连接进行了确认，将server_isn+1放到确认字段中。因为连接已经建立，所以SYN被置为0。该握手可以携带应用层数据。

![三次握手的报文交换](/images/computer-networking/transport-layer/TCP-three-way-handshake.png)

### 序号(Seq)与确认号（ACK）

TCP连接双方可以随机选择起始序号。减少已中断连接的相同序号的报文。序号是建立在字节流之上，一个报文段的序号，是字节流编号。

![被编号的文件流](/images/computer-networking/transport-layer/TCP-data-segment.png)

确认号是接收方期望的下一个报文的编号。主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。假设主机A接收到来自主机B编号为0~355的所有字节，同时假设打算给主机B发送一个报文，A等待B数据字节536之后的所有字节，所以A就会在确认号中填充536。TCP只确认流中第一个丢失的字节。

如果双方连接建立时的起始为42、79，则它们分别等待序号为79、42的报文。

![一个Telnet应用的序号和确认号](/images/computer-networking/transport-layer/Telnet-application-over-TCP.png)

如上，ACK报文可以被装载在具有数据的报文中，随数据一起交付。

网络层服务是不可靠的，TCP在IP不可靠的尽力而为的服务上创建了可靠传输协议，确保一个进程从其接收缓存上读出的数据流是无损坏的、无间隔的、非冗余的、按序的。定时器被关联到最早未被确认的报文段。

### 累积确认

TCP发送方维持已发送过但未被确认字节的最小序号（sendBase）和下一个要发送的字节序号（NextSeqNum），这两个变量组成了一个滑动窗口。TCP接收方会将失序的分组缓存起来。当发送分组1、2、......、N时，若分组n < N丢失，且接收到其余N-1个分组，对接收到n以后的失序分组时，接收方只会对第n-1个分组进行确认。触发重传，接收到分组n后，接收方将对分组N进行确认。这就是累积确认。

### 可靠传输

TCP就是在不可靠的端到端网络上实现的可靠传输协议。

TCP对数据按流进行标号，报文段的序号就是数据首字节的字节流编号，当报文发送后，为该报文段开启定时器。当定时器超时后，重传该报文，并重启定时器。确认号就是接收方期望的下一字节序号，当接收方收到ACK时，如果窗口内的报文都被确认，则移动窗口。当超时发生后，重传最小编号的报文。

发送方收到数据后，如果是按序的报文（前面的报文都被确认），此时会等待一段时间，等待下一个报文，如果没有新报文，就发送ACK。如果是乱序报文，立刻发送重复ACK（期望的报文序号）。

为了让发送方了解接收方的情况，需要让接收方提供反馈信息给发送方。反馈报文为ACK（Acknowledgment，肯定确认）。接收方有差错分组时需要重传。


### 快速重传

当接收方收到一个序号大于下一个所期望的、按序的报文段时，说明产生了间隔，他会对已接收到的最后一个按序字节数据进行重复确认。因为发送方经常大量发送报文段如果一个报文段丢失，就可能引起许多一个接一个的冗余ACK。如果发送方收到相同的冗余ACK 3次。说明跟在这个报文段后的报文段已经丢失。发送方就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。

## TCP连接关闭

如果客户端想要断开连接，客户端会发送断开连接命令，该过程称为**四次挥手**（four-way handshake），这个过程使得双方的状态得以[*同步*](https://www.zhihu.com/question/67013338/answer/248375813)。过程如下：

- 客户端发送一个特殊的TCP报文段，其FIN字段被置为1
- 服务器收到后，向发送方发送确认报文，并关闭连接
- 然后，服务器发送自己的FIN报文
- 客户端对这个FIN报文进行确认，此时，两台主机上的连接资源被释放

![关闭TCP连接](/images/computer-networking/transport-layer/TCP_CLOSE.svg)

## SYN泛洪攻击

服务响应一个握手SYN是，分配连接变量和缓存。如果客户端在第三次握手时，不发送ACK完成第三次握手，最终，服务器将终止半开连接并回收资源。这位SYN泛洪攻击提供了环境。攻击者发送大量的TCP SYN报文，而不完成第三步。服务器不断为这种半开连接分配资源，导致服务器连接资源消耗殆尽。

SYN Cookie能够有效抵御这种攻击。工作方式如下：

- 初始时，服务器并不会直接为连接分配资源。相反，它首先生成一个初始TCP序列号，该序列号由SYN源和目的IP地址与端口号，通过一个复杂的Hash函数生成的，称为cookie。服务器发送具有这种特殊初始序列号的SYNACK分组。并且服务器不记录该cookie或任何对应与SYN的其他状态信息。
- 如果客户端返回ACK，服务器需要验证该ACK是否与前面发送的ACK相匹配。服务器将ACK报文的源和目的IP地址做相同的Hash运算，如果该运算值加1与该ACK报文的确认字段相同，则服务器生成具有套接字的全开连接。